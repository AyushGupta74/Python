Solution.1:
from abc import ABC, abstractmethod

class Appliance(ABC):
    @abstractmethod
    def turn_on():
        pass

    @abstractmethod
    def turn_off():
        pass

class Fan(Appliance):
    
    def turn_on(self):
        print("\n----Fan is ON----\n")

    
    def turn_off(self):
        print("\n----Fan is OFF----\n")

class Light(Appliance):
    
    def turn_on(self):
        print("\n----Light is ON----\n")

    
    def turn_off(self):
        print("\n----Light is OFF----\n")

f = Fan()
f.turn_on()
f.turn_off()

l = Light()
l.turn_on()
l.turn_off()

-----------------------------------------------------------------------------------------------

Solution.2:
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area():
        pass

    @abstractmethod
    def display_shape():
        pass

class Circle(Shape):
    
    def area(self):
        print("\n----Area of Circle----\n")

    
    def display_shape(self):
        print("\n----Shape is Circle----\n")

class Rectangle(Shape):
    
    def area(self):
        print("\n----Area of Rectangle----\n")

    
    def display_shape(self):
        print("\n----Shape is Rectangle----\n")

c = Circle()
c.area()
c.display_shape()

r = Rectangle()
r.area()
r.display_shape()

-----------------------------------------------------------------------------------------------

Solution.3:
def greet_decorator(func):
    def wrapper():
        print("Hello ", end = "")
        func()
        return 
    return wrapper

@greet_decorator
def greet():
    print("User")

greet()

-----------------------------------------------------------------------------------------------

Solution.4:
def  log_arguments(func):
    def wrapper(*args, **kwargs):
        print(f"Positional Arguments: {args}")
        print(f"Keyword Arguments: {kwargs}")
        result = func(*args)
        return result
    return wrapper

@log_arguments
def sum(a, b):
    return a + b

print(f"Result: {sum(10,20)}")

-----------------------------------------------------------------------------------------------

Solution.5:
def  log_method_call(func):
    def wrapper(*args, **kwargs):
        print(f"Calling method: {func.__name__}")
        return func(*args,**kwargs)
    return wrapper


class Myclass():
    @log_method_call
    def greet(self,name):
        print(f"Hello {name}!!")

obj = Myclass()
obj.greet("User")

***********************************EXCEPTION HANDLING******************************************

Solution.1:
try:
    result = 5/0

except Exception as e:
    print(f"Error found: {e}")

-----------------------------------------------------------------------------------------------

Solution.2:
array = [1,2,3,4]
try:
    result = array[4]

except IndexError as ie:
    print(f"Index error caught: {ie}")

-----------------------------------------------------------------------------------------------

Solution.3:
import os

file = input("Enter file path: ")

try:
    if not os.path.exists(file):
        raise FileNotFoundError(f"File {file} does not exist.")
    with open(file, "w", encoding="utf-8") as f:
        entry = input("Enter data to be written in file(Numeric): ")
        float(entry)
        f.write(entry)

except FileNotFoundError as fe:
    print(f"File error: {fe}")

except ValueError as ve:
    print(f"You entered a non-numeric data.")

-----------------------------------------------------------------------------------------------

Solution.4:
class MyCustomError(Exception):
    '''Raised when a specific custom error condition occurs.'''
    def __init__(self,message):
        super().__init__(message)

entry = int(input("Enter your age: "))

try:
    if entry<0 or entry>150:
        raise MyCustomError("Age must be above 0 or under 150")
    else:
        print("Age confirmed.")
    
except MyCustomError as me:
    print(f"Custom error is caught: {me}")

-----------------------------------------------------------------------------------------------

Solution.5:
try:
    num1 = int(input("Enter number 1: "))
    num2 = int(input("Enter number 2: "))

    div = num1 / num2  # This will raise ZeroDivisionError if num2 is 0

except ZeroDivisionError:
    print("Error: Cannot divide by zero.")

except ValueError:
    print("Error: Please enter valid integers.")

else:
    print(f"Result: {div}")

finally:
    print("Operation complete.")

-----------------------------------------------------------------------------------------------

Solution.6:
try:
    str = input("Enter a string: ")
    num = int(str)

except TypeError:
    print("Error: Please enter a string.")

except ValueError:
    print("Error: Please enter valid integers.")

else:
    print(f"Result: {num}")

finally:
    print("Operation complete.")

-----------------------------------------------------------------------------------------------

Solution.7:
class MyCustomError(Exception):
    '''Raised when a specific custom error condition occurs.'''
    def __init__(self,message):
        super().__init__(message)

def function1():
    raise MyCustomError("Custom error occured in function1")

def function2():
    try:
        function1()
    except MyCustomError as e:
        raise RuntimeError("function2 failed due to an error in function1") from e

try:
    function2()
except Exception as final_error:
    print(f"Caught in main: {final_error}")
    print(f"Original cause: {final_error.__cause__}")

-----------------------------------------------------------------------------------------------

Solution.8:
list_ex = [1,2,3,4]
dict_ex = {1:'a',2:'b',3:'c',4:'d'}

def handle_errors(operation):
    try:
        operation()
    except (IndexError, KeyError) as e:
        if isinstance(e, IndexError):
            print(f"IndexError: Please choose a valid index. Details: {e}")
        elif isinstance(e, KeyError):
            print(f"KeyError: Please choose a valid key. Details: {e}")

handle_errors(lambda: list_ex[5])
handle_errors(lambda: dict_ex[6])

-----------------------------------------------------------------------------------------------

Solution.9:
filename = "testfile.txt"
try:
    with open(filename, 'r', encoding='utf-8') as file:
        for line in file:
            try:
                if float(line):
                    print(line, end="")
            except Exception as e:
                print("Non numeric data found.")
        print()
except Exception as e:
    print(f"Error: {e}")

-----------------------------------------------------------------------------------------------

Solution.10:
filename = "testfile.txt"
try:
    with open(filename, 'r', encoding='utf-8') as file:
        file.write("Writing in a read only file. This will fail!")
except Exception as e:
    print(f"Error: {e}")

-----------------------------------------------------------------------------------------------

Solution.11:
x = int(input("Enter value of x: "))

try:
    if x<0:
        raise Exception("x is lower than 0")
except Exception as e:
    print(f"Error: {e}")

-----------------------------------------------------------------------------------------------

Solution.12:
def check_integer(x):
    try:
        if not isinstance(x, int):
            raise TypeError(f"Expected an integer, but got \'{x}\' which is {type(x).__name__}")
        else:
            print(f"{x} is a valid integer.")
    except TypeError as t:
        print(f"Type Error: {t}")

check_integer(49)
check_integer('cdac')